"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var pipeline_module_1 = require("./pipeline-module");
var type_prefixes_1 = require("./type-prefixes");
var namespaces_1 = require("./namespaces");
var default_resolvers_1 = require("./default-resolvers");
var abstract_types_1 = require("./abstract-types");
var links_1 = require("./links");
var proxy_resolvers_1 = require("./proxy-resolvers");
var merge_extended_schemas_1 = require("../extended-schema/merge-extended-schemas");
var extended_introspection_1 = require("./extended-introspection");
var additional_metadata_1 = require("./additional-metadata");
var custom_scalar_types_serialization_1 = require("./custom-scalar-types-serialization");
var error_resolvers_1 = require("./error-resolvers");
function createPreMergeModules(context, customConfig) {
    var customizableModules = [];
    if (context.endpointConfig.typePrefix) {
        customizableModules.push(new type_prefixes_1.TypePrefixesModule(context.endpointConfig.typePrefix));
    }
    if (context.endpointConfig.namespace) {
        customizableModules.push(new namespaces_1.NamespaceModule(context.endpointConfig.namespace));
    }
    if (customConfig && customConfig.transformPreMergePipeline) {
        customizableModules = customConfig.transformPreMergePipeline(customizableModules, context);
    }
    return [
        // those three make the schema fully-functional
        new proxy_resolvers_1.ProxyResolversModule(context),
        new default_resolvers_1.DefaultResolversModule(),
        new error_resolvers_1.ErrorResolversModule(),
        new custom_scalar_types_serialization_1.CustomScalarTypesSerializationModule(),
        new abstract_types_1.AbstractTypesModule(),
        // there should be no reason to change this one either
        new additional_metadata_1.AdditionalMetadataModule(context.endpointConfig)
    ].concat(customizableModules);
}
function createPostMergeModules(context, customConfig) {
    var customizableModules = [
        new links_1.LinksModule({ reportError: context.reportError })
    ];
    if (customConfig && customConfig.transformPostMergePipeline) {
        customizableModules = customConfig.transformPostMergePipeline(customizableModules, context);
    }
    return customizableModules.concat([
        // this needs to be at the end
        new extended_introspection_1.ExtendedIntrospectionModule(),
        // do this here again to catch FieldErrorValues generated by other modules, e.g. by link modules
        // somehow we would either need to do this before each module that executes its given (base) schema,
        // or after modules that call moveErrorsToData() (because that generates the FieldErrorValues)
        // don't know yet how do do this properly, so as a first version, we just do it once in the beginning and once
        // at the end
        new error_resolvers_1.ErrorResolversModule()
    ]);
}
var Pipeline = /** @class */ (function () {
    function Pipeline(endpoints, reportError, customConfig) {
        var _this = this;
        this.endpoints = endpoints;
        var extendedEndpoints = endpoints.map(function (endpoint) { return (__assign({}, endpoint, { reportError: reportError, processQuery: function (query) { return _this.processQuery(query, endpoint.endpointConfig.identifier); } })); });
        this.preMergeModules = new Map(extendedEndpoints.map(function (context) {
            return [
                context.endpointConfig.identifier,
                createPreMergeModules(context, customConfig) // map value
            ];
        }));
        this.postMergeModules = createPostMergeModules({
            endpoints: extendedEndpoints,
            reportError: reportError
        }, customConfig);
    }
    Object.defineProperty(Pipeline.prototype, "schema", {
        get: function () {
            if (!this._schema) {
                this._schema = this.createSchema();
            }
            return this._schema;
        },
        enumerable: true,
        configurable: true
    });
    Pipeline.prototype.createSchema = function () {
        var _this = this;
        var schemas = this.endpoints.map(function (endpoint) {
            var schema = endpoint.schema;
            return pipeline_module_1.runSchemaPipeline(_this.preMergeModules.get(endpoint.endpointConfig.identifier), schema);
        });
        var schema = merge_extended_schemas_1.mergeExtendedSchemas.apply(void 0, schemas);
        return pipeline_module_1.runSchemaPipeline(this.postMergeModules, schema);
    };
    Pipeline.prototype.processQuery = function (query, endpointIdentifier) {
        if (!this.preMergeModules.has(endpointIdentifier)) {
            throw new Error("Endpoint " + endpointIdentifier + " does not exist");
        }
        var preMergeModules = this.preMergeModules.get(endpointIdentifier);
        return pipeline_module_1.runQueryPipeline(preMergeModules.concat(this.postMergeModules).reverse(), query);
    };
    return Pipeline;
}());
exports.Pipeline = Pipeline;
//# sourceMappingURL=pipeline.js.map