"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var utils_1 = require("./utils");
function removeUnusedTypesFromSchema(schema) {
    var rootTypes = utils_1.compact([schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()]);
    var objectTypes = utils_1.objectValues(schema.getTypeMap()).filter(function (type) { return type instanceof graphql_1.GraphQLObjectType; });
    return new graphql_1.GraphQLSchema({
        query: schema.getQueryType(),
        mutation: schema.getMutationType() || undefined,
        subscription: schema.getSubscriptionType() || undefined,
        directives: schema.getDirectives(),
        types: filterUsableInterfaceImplementations(objectTypes, rootTypes)
    });
}
exports.removeUnusedTypesFromSchema = removeUnusedTypesFromSchema;
/**
 * Finds all interface types that are reachable through any of the given types
 */
function findAllReachableInterfaces(types) {
    var visitedTypes = new Set();
    var interfaces = new Set();
    function visitType(type) {
        type = graphql_1.getNamedType(type);
        if (visitedTypes.has(type)) {
            return;
        }
        visitedTypes.add(type);
        if (type instanceof graphql_1.GraphQLUnionType) {
            for (var _i = 0, _a = type.getTypes(); _i < _a.length; _i++) {
                var option = _a[_i];
                visitType(option);
            }
        }
        else if (type instanceof graphql_1.GraphQLInterfaceType || type instanceof graphql_1.GraphQLObjectType) {
            if (type instanceof graphql_1.GraphQLInterfaceType) {
                interfaces.add(type);
            }
            for (var _b = 0, _c = utils_1.objectValues(type.getFields()); _b < _c.length; _b++) {
                var field = _c[_b];
                visitType(field.type);
            }
        }
    }
    for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
        var type = types_1[_i];
        visitType(type);
    }
    return interfaces;
}
/**
 * Finds all object types that implement any of the interfaces reachable from any of the rootTypes
 * @param rootTypes types that are used fo reachability test
 * @param candidates the types which are filtered
 * @return the object types that are usable
 */
function filterUsableInterfaceImplementations(candidates, rootTypes) {
    var reachableInterfaces = findAllReachableInterfaces(rootTypes);
    var implementations = new Set();
    var hasFoundNewInterfaces = false;
    do {
        var newImplementations = candidates
            .filter(function (objectType) { return objectType.getInterfaces().some(function (implementedInterface) { return reachableInterfaces.has(implementedInterface); }); });
        for (var _i = 0, newImplementations_1 = newImplementations; _i < newImplementations_1.length; _i++) {
            var impl = newImplementations_1[_i];
            implementations.add(impl);
        }
        // we might have introduced some new fields that make use of interfaces which need to be added to reachableInterfaces
        var newInterfaces = findAllReachableInterfaces(newImplementations);
        hasFoundNewInterfaces = false;
        for (var _a = 0, _b = Array.from(newInterfaces); _a < _b.length; _a++) {
            var newlyFoundInterface = _b[_a];
            if (!reachableInterfaces.has(newlyFoundInterface)) {
                // found some new interfaces, so trigger a new round
                hasFoundNewInterfaces = true;
                reachableInterfaces.add(newlyFoundInterface);
            }
        }
    } while (hasFoundNewInterfaces);
    return Array.from(implementations);
}
exports.filterUsableInterfaceImplementations = filterUsableInterfaceImplementations;
//# sourceMappingURL=remove-unused-types.js.map