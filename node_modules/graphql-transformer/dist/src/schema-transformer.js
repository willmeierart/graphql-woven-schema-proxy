"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var native_symbols_1 = require("./native-symbols");
var utils_1 = require("./utils");
var schema_utils_1 = require("./schema-utils");
var remove_unused_types_1 = require("./remove-unused-types");
function combineTransformationFunctions(fns) {
    var definedFns = utils_1.compact(fns);
    if (!definedFns.length) {
        return undefined;
    }
    return function (config, context) { return definedFns.reduce(function (config, fn) { return fn(config, context); }, config); };
}
/**
 * Binds all SchemaTransformer methods to the SchemaTransformer itself, effectively converting a class to a function tuple
 * @param {SchemaTransformer[]} t
 * @returns {SchemaTransformer}
 */
function bindTransformerFunctions(t) {
    return {
        transformScalarType: utils_1.bindNullable(t.transformScalarType, t),
        transformEnumType: utils_1.bindNullable(t.transformEnumType, t),
        transformInterfaceType: utils_1.bindNullable(t.transformInterfaceType, t),
        transformInputObjectType: utils_1.bindNullable(t.transformInputObjectType, t),
        transformUnionType: utils_1.bindNullable(t.transformUnionType, t),
        transformObjectType: utils_1.bindNullable(t.transformObjectType, t),
        transformDirective: utils_1.bindNullable(t.transformDirective, t),
        transformField: utils_1.bindNullable(t.transformField, t),
        transformInputField: utils_1.bindNullable(t.transformInputField, t)
    };
}
exports.bindTransformerFunctions = bindTransformerFunctions;
/**
 * Combines multiple transformers that into one that executes the transformation functions in the given order
 */
function combineTransformers() {
    var transformers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        transformers[_i] = arguments[_i];
    }
    var boundTransformers = transformers.map(function (t) { return bindTransformerFunctions(t); });
    return {
        transformScalarType: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformScalarType; })),
        transformEnumType: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformEnumType; })),
        transformInterfaceType: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformInterfaceType; })),
        transformInputObjectType: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformInputObjectType; })),
        transformUnionType: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformUnionType; })),
        transformObjectType: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformObjectType; })),
        transformDirective: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformDirective; })),
        transformField: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformField; })),
        transformInputField: combineTransformationFunctions(boundTransformers.map(function (t) { return t.transformInputField; }))
    };
}
exports.combineTransformers = combineTransformers;
/**
 * Clones a GraphQLSchema by destructuring it into GraphQL's config objects and executes custom transformers
 * on these config objects
 *
 * @param schema
 * @param transformers
 */
function transformSchema(schema, transformers) {
    var transformer = new Transformer(transformers, schema);
    return transformer.transform();
}
exports.transformSchema = transformSchema;
// this is not really an OOP class but it is useful to keep track of state. It is not exported, so this is fine
var Transformer = /** @class */ (function () {
    function Transformer(transformers, schema) {
        this.transformers = transformers;
        this.schema = schema;
        this.typeMap = {};
    }
    /**
     * only call once
     */
    Transformer.prototype.transform = function () {
        var _this = this;
        var schema = this.schema;
        // Dependencies between fields and their are broken up via GraphQL's thunk approach (fields are only requested when
        // needed, which is after all types have been converted). However, an object's reference to its implemented
        // interfaces and a union's reference to its option types do not support the thunk approach, so we need to make
        // sure they are transformed first
        // -> interfaces first, then objects, then unions
        var originalTypes = schema_utils_1.orderTypesTopologically(utils_1.objectValues(schema.getTypeMap()));
        for (var _i = 0, originalTypes_1 = originalTypes; _i < originalTypes_1.length; _i++) {
            var type = originalTypes_1[_i];
            this.processType(type);
        }
        var directives = schema.getDirectives()
            .map(function (directive) { return native_symbols_1.isNativeDirective(directive) ? directive : _this.transformDirective(directive, _this.transformers); });
        var findNewTypeMaybe = function (type) {
            if (!type) {
                return undefined;
            }
            var newType = _this.findType(type.name);
            return newType;
        };
        var query = findNewTypeMaybe(schema.getQueryType());
        var mutation = findNewTypeMaybe(schema.getMutationType());
        var subscription = findNewTypeMaybe(schema.getSubscriptionType());
        var rootTypes = utils_1.compact([query, mutation, subscription]);
        var objectTypes = utils_1.objectValues(this.typeMap).filter(function (type) { return type instanceof graphql_1.GraphQLObjectType; });
        // filter unused types before GraphQLSchema construction to avoid type collisions with unused types
        var requiredObjectTypes = remove_unused_types_1.filterUsableInterfaceImplementations(objectTypes, rootTypes);
        return new graphql_1.GraphQLSchema({
            directives: directives,
            query: query,
            mutation: mutation,
            subscription: subscription,
            types: requiredObjectTypes
        });
    };
    /**
     * Finds the type in the new schema by its name in the old schema
     * @param oldName the old type name
     * @returns {GraphQLNamedType}
     */
    Transformer.prototype.findType = function (oldName) {
        if (!(oldName in this.typeMap)) {
            throw new Error("Unexpected reference to type " + oldName);
        }
        return this.typeMap[oldName];
    };
    /**
     * Maps a type in the old schema to a type in the new schema, supporting list and optional types.
     */
    Transformer.prototype.mapType = function (type) {
        if (type instanceof graphql_1.GraphQLList) {
            return new graphql_1.GraphQLList(this.mapType(type.ofType));
        }
        if (type instanceof graphql_1.GraphQLNonNull) {
            return new graphql_1.GraphQLNonNull(this.mapType(type.ofType));
        }
        var namedType = type; // generics seem to throw off type guard logic
        if (native_symbols_1.isNativeGraphQLType(namedType)) {
            // do not rename native types but keep the reference to singleton objects like GraphQLString
            return type;
        }
        return this.findType(namedType.name);
    };
    Object.defineProperty(Transformer.prototype, "transformationContext", {
        get: function () {
            return {
                mapType: this.mapType.bind(this),
                findType: this.findType.bind(this),
                oldSchema: this.schema,
                copyType: this.copyType.bind(this)
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a new type for the given old type and stores it in the type map
     * @param type
     */
    Transformer.prototype.processType = function (type) {
        if (type.name.substring(0, 2) === '__' || native_symbols_1.isNativeGraphQLType(type)) {
            // do not touch native types or introspection types like __Schema
            return;
        }
        this.typeMap[type.name] = this.transformType(type);
    };
    /**
     * Creates a new type for the given old type. Interfaces are expected to be already present; fields are resolved lazily
     */
    Transformer.prototype.transformType = function (type) {
        return this.copyType(type, this.transformers);
    };
    Transformer.prototype.copyType = function (type, transformer) {
        if (type instanceof graphql_1.GraphQLScalarType) {
            return this.transformScalarType(type, transformer);
        }
        if (type instanceof graphql_1.GraphQLObjectType) {
            return this.transformObjectType(type, transformer);
        }
        if (type instanceof graphql_1.GraphQLInputObjectType) {
            return this.transformInputObjectType(type, transformer);
        }
        if (type instanceof graphql_1.GraphQLInterfaceType) {
            return this.transformInterfaceType(type, transformer);
        }
        if (type instanceof graphql_1.GraphQLUnionType) {
            return this.transformUnionType(type, transformer);
        }
        if (type instanceof graphql_1.GraphQLEnumType) {
            return this.transformEnumType(type, transformer);
        }
        throw new Error("Unsupported type: " + type);
    };
    Transformer.prototype.transformScalarType = function (type, transformer) {
        var config = {
            name: type.name,
            description: type.description,
            serialize: type.serialize.bind(type),
            parseLiteral: type.parseLiteral.bind(type),
            parseValue: type.parseValue.bind(type),
            astNode: type.astNode
        };
        if (transformer.transformScalarType) {
            config = transformer.transformScalarType(config, __assign({}, this.transformationContext, { oldType: type }));
        }
        return new graphql_1.GraphQLScalarType(config);
    };
    Transformer.prototype.transformObjectType = function (type, transformer) {
        var _this = this;
        var config = {
            name: type.name,
            description: type.description,
            fields: function () { return _this.transformFields(type.getFields(), __assign({}, _this.transformationContext, { oldOuterType: type, newOuterType: _this.mapType(type) }), transformer); },
            interfaces: type.getInterfaces().map(function (iface) { return _this.mapType(iface); }),
            isTypeOf: type.isTypeOf,
            astNode: type.astNode
        };
        if (transformer.transformObjectType) {
            config = transformer.transformObjectType(config, __assign({}, this.transformationContext, { oldType: type }));
        }
        return new graphql_1.GraphQLObjectType(config);
    };
    Transformer.prototype.transformInterfaceType = function (type, transformer) {
        var _this = this;
        var config = {
            name: type.name,
            description: type.description,
            resolveType: this.transformTypeResolver(type.resolveType, transformer),
            fields: function () { return _this.transformFields(type.getFields(), {
                oldOuterType: type,
                newOuterType: _this.mapType(type)
            }, transformer); },
            astNode: type.astNode
        };
        if (transformer.transformInterfaceType) {
            config = transformer.transformInterfaceType(config, __assign({}, this.transformationContext, { oldType: type }));
        }
        return new graphql_1.GraphQLInterfaceType(config);
    };
    /**
     * Creates field configs for all provided fields, but with remapped types and argument types. All named
     * types are sent through the typeResolver with their old name to determine the new type.
     */
    Transformer.prototype.transformFields = function (originalFields, context, transformer) {
        var fields = {};
        for (var fieldName in originalFields) {
            var originalField = originalFields[fieldName];
            var fieldConfig = {
                name: fieldName,
                description: originalField.description,
                deprecationReason: originalField.deprecationReason,
                type: this.mapType(originalField.type),
                args: this.transformArguments(originalField.args),
                resolve: originalField.resolve,
                astNode: originalField.astNode
            };
            if (transformer.transformField) {
                fieldConfig = transformer.transformField(fieldConfig, __assign({}, this.transformationContext, { oldField: originalField, oldOuterType: context.oldOuterType, newOuterType: context.newOuterType }));
            }
            if (fieldConfig.name in fields) {
                throw new Error("Duplicate field name " + fieldConfig + " in " + context.oldOuterType.name);
            }
            fields[fieldConfig.name] = fieldConfig;
        }
        if (transformer.transformFields) {
            fields = transformer.transformFields(fields, __assign({}, this.transformationContext, { oldFields: originalFields, oldOuterType: context.oldOuterType, newOuterType: context.newOuterType }));
        }
        return fields;
    };
    Transformer.prototype.transformArguments = function (originalArgs) {
        var args = {};
        for (var _i = 0, originalArgs_1 = originalArgs; _i < originalArgs_1.length; _i++) {
            var arg = originalArgs_1[_i];
            args[arg.name] = {
                description: arg.description,
                type: this.mapType(arg.type),
                defaultValue: arg.defaultValue,
                astNode: arg.astNode
            };
        }
        return args;
    };
    Transformer.prototype.transformInputObjectType = function (type, transformer) {
        var _this = this;
        var getFields = function () {
            var originalFields = type.getFields();
            var fields = {};
            for (var fieldName in originalFields) {
                var originalField = originalFields[fieldName];
                var fieldConfig = {
                    name: fieldName,
                    description: originalField.description,
                    defaultValue: originalField.defaultValue,
                    type: _this.mapType(originalField.type),
                    astNode: originalField.astNode
                };
                if (transformer.transformInputField) {
                    fieldConfig = transformer.transformInputField(fieldConfig, __assign({}, _this.transformationContext, { oldField: originalField, oldOuterType: type, newOuterType: _this.mapType(type) }));
                }
                if (fieldConfig.name in fields) {
                    throw new Error("Duplicate field name " + fieldConfig + " in input type " + type.name);
                }
                fields[fieldConfig.name] = fieldConfig;
            }
            return fields;
        };
        var config = {
            name: type.name,
            description: type.description,
            fields: getFields,
            astNode: type.astNode
        };
        if (transformer.transformInputObjectType) {
            config = transformer.transformInputObjectType(config, __assign({}, this.transformationContext, { oldType: type }));
        }
        return new graphql_1.GraphQLInputObjectType(config);
    };
    Transformer.prototype.transformEnumType = function (type, transformer) {
        var values = {};
        for (var _i = 0, _a = type.getValues(); _i < _a.length; _i++) {
            var originalValue = _a[_i];
            values[originalValue.name] = {
                description: originalValue.description,
                value: originalValue.value,
                deprecationReason: originalValue.deprecationReason,
                astNode: originalValue.astNode
            };
        }
        var config = {
            name: type.name,
            description: type.description,
            values: values,
            astNode: type.astNode
        };
        if (transformer.transformEnumType) {
            config = transformer.transformEnumType(config, __assign({}, this.transformationContext, { oldType: type }));
        }
        return new graphql_1.GraphQLEnumType(config);
    };
    Transformer.prototype.transformUnionType = function (type, transformer) {
        var _this = this;
        var config = {
            name: type.name,
            description: type.description,
            types: type.getTypes().map(function (optionType) { return _this.mapType(optionType); }),
            resolveType: this.transformTypeResolver(type.resolveType, transformer),
            astNode: type.astNode
        };
        if (transformer.transformUnionType) {
            config = transformer.transformUnionType(config, __assign({}, this.transformationContext, { oldType: type }));
        }
        return new graphql_1.GraphQLUnionType(config);
    };
    Transformer.prototype.transformDirective = function (directive, transformer) {
        var config = {
            name: directive.name,
            description: directive.description,
            locations: directive.locations,
            args: this.transformArguments(directive.args),
            astNode: directive.astNode
        };
        if (transformer.transformDirective) {
            config = transformer.transformDirective(config, __assign({}, this.transformationContext, { oldDirective: directive }));
        }
        return new graphql_1.GraphQLDirective(config);
    };
    Transformer.prototype.transformTypeResolver = function (typeResolver, transformer) {
        var _this = this;
        if (!typeResolver) {
            return typeResolver;
        }
        return function (value, context, info) {
            var result = typeResolver(value, context, info);
            if (typeof result == 'string') {
                return _this.findType(result);
            }
            if (result instanceof graphql_1.GraphQLObjectType) {
                return _this.mapType(result);
            }
            return result.then(function (r) { return typeof r == 'string' ? _this.findType(r) : _this.mapType(r); });
        };
    };
    return Transformer;
}());
//# sourceMappingURL=schema-transformer.js.map