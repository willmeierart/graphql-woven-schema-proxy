"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graphql_1 = require("graphql");
var nativeTypes = [graphql_1.GraphQLInt, graphql_1.GraphQLString, graphql_1.GraphQLBoolean, graphql_1.GraphQLFloat, graphql_1.GraphQLID];
var nativeTypeMap = {};
for (var _i = 0, nativeTypes_1 = nativeTypes; _i < nativeTypes_1.length; _i++) {
    var type = nativeTypes_1[_i];
    nativeTypeMap[type.name] = type;
}
/**
 * Determines if the given type is natively included in any GraphQL schema (and it is not an introspection type)
 * @param type a GraphQLType or a a type name
 * @returns true for native types, false for other types and for introspection types
 */
function isNativeGraphQLType(type) {
    var name = typeof type === 'string' ? type : type.name;
    return name in nativeTypeMap;
}
exports.isNativeGraphQLType = isNativeGraphQLType;
var nativeDirectiveMap = {};
for (var _a = 0, specifiedDirectives_1 = graphql_1.specifiedDirectives; _a < specifiedDirectives_1.length; _a++) {
    var directive = specifiedDirectives_1[_a];
    nativeDirectiveMap[directive.name] = directive;
}
/**
 * Determines if the given directive is natively included in any GraphQL schema
 *
 * This function uses name equality to compare directives, not referential equality. Thus, directives generated from an
 * introspection query with the correct name will be identified as native directives. However, it also means that
 * non-standard directives with native names will be treated as if they were native directives.
 *
 * @param directive a GraphQLDirective or a a directive name
 * @returns true for native directives, false otherwise
 */
function isNativeDirective(directive) {
    var name = typeof directive === 'string' ? directive : directive.name;
    return name in nativeDirectiveMap;
}
exports.isNativeDirective = isNativeDirective;
//# sourceMappingURL=native-symbols.js.map